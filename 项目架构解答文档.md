# 全栈项目架构详细解答文档

## 1. 项目架构梳理

### 整体架构概览
这是一个基于 pnpm workspaces 的 monorepo 项目，采用现代的全栈 TypeScript 技术栈：

```
fullstack-boilerplate/
├── apps/                    # 应用层
│   ├── server/             # 后端 Hono 服务器
│   └── web/                # 前端 Vite+React 应用
├── packages/               # 共享包
│   ├── api/                # API 合约和客户端
│   ├── auth/               # Better Auth 认证模块
│   ├── db/                 # 数据库 Schema 和操作
│   └── ui/                 # UI 组件库（推测）
└── 配置文件...
```

### 各 Package 详细作用

#### packages/db - 数据库层
- **作用**: 统一管理数据库 schema 和类型定义
- **技术栈**: Drizzle ORM + PostgreSQL + Valibot 验证
- **主要文件**:
  - `src/schemas/posts.schema.ts`: Post 表定义和创建验证 schema
  - `src/schemas/auth.schema.ts`: 用户认证相关表定义
  - `src/schema.ts`: 导出所有 schema
- **输出**: 数据库表定义、插入验证 schema、类型定义

#### packages/auth - 认证模块  
- **作用**: 统一的认证解决方案
- **技术栈**: Better Auth + Drizzle 适配器
- **主要功能**: 
  - 邮箱密码登录
  - Session 管理
  - OpenAPI 插件支持
- **配置**: 支持自定义 baseURL、信任源、session 策略等

#### packages/api - API 合约和客户端
- **作用**: 类型安全的 API 接口定义和客户端生成
- **技术栈**: ORPC (OpenAPI RPC) + Valibot
- **结构**:
  - `src/contracts/`: API 合约定义（如 posts.ts）
  - `src/server/`: 服务端路由实现
  - `src/client/`: 客户端 SDK 生成
- **特色**: 自动生成 TypeScript 类型，支持 Tanstack Query 集成

### 前后端打通流程

#### 类型安全链路:
```
DB Schema (Drizzle) → API Contract (ORPC) → Server Implementation → Client SDK → Frontend
```

#### 具体流程:
1. **数据层**: `@repo/db` 定义数据库 schema 和验证规则
2. **合约层**: `@repo/api/contracts` 引用 DB schema，定义 API 输入输出类型
3. **服务端**: `@repo/api/server` 实现具体的业务逻辑
4. **客户端**: `@repo/api/client` 自动生成类型安全的客户端 SDK
5. **前端**: 直接导入客户端 SDK，获得完整的类型提示和验证

## 2. 新增接口的完整操作步骤

假设我们要新增一个 "评论" 功能，以下是详细步骤：

### 步骤 1: 定义数据库 Schema
```typescript
// packages/db/src/schemas/comments.schema.ts
export const comment = pgTable('comment', (t) => ({
  id: t.uuid().primaryKey().defaultRandom(),
  content: t.text().notNull(),
  postId: t.uuid().references(() => post.id).notNull(),
  createdBy: t.text().references(() => user.id).notNull(),
  createdAt: t.timestamp({ mode: 'string', withTimezone: true }).notNull().defaultNow(),
}));

export const CreateCommentSchema = v.omit(
  createInsertSchema(comment, {
    content: v.pipe(v.string(), v.minLength(1), v.maxLength(500)),
  }),
  ['id', 'createdAt', 'createdBy'],
);
```

### 步骤 2: 导出 Schema
```typescript
// packages/db/src/schema.ts
export * from './schemas/comments.schema';
```

### 步骤 3: 定义 API 合约
```typescript
// packages/api/src/contracts/comments.ts
import { oc } from '@orpc/contract';
import { CreateCommentSchema } from '@repo/db/schema';
import * as v from 'valibot';

const commentContract = oc
  .prefix('/comments')
  .tag('comment')
  .router({
    create: oc
      .route({
        method: 'POST',
        path: '/',
        summary: 'Create a comment',
        description: 'Add a comment to a post',
      })
      .input(CreateCommentSchema)
      .output(v.object({ id: v.string() })),
      
    byPost: oc
      .route({
        method: 'GET', 
        path: '/post/{postId}',
        summary: 'Get comments by post',
      })
      .input(v.object({ postId: v.string() }))
      .output(v.array(v.object({
        id: v.string(),
        content: v.string(),
        createdAt: v.string(),
        author: v.object({
          id: v.string(),
          name: v.string(),
        }),
      }))),
  });

export default commentContract;
```

### 步骤 4: 注册合约到主路由
```typescript
// packages/api/src/contracts/index.ts
import commentContract from './comments';

export const appContract = oc.router({
  posts: postContract,
  comments: commentContract, // 新增这行
});
```

### 步骤 5: 实现服务端路由
```typescript
// packages/api/src/server/router/comment.ts
import { eq } from '@repo/db';
import { comment, user } from '@repo/db/schema';
import { protectedProcedure } from '../orpc';

const commentRouter = {
  create: protectedProcedure.comments.create.handler(
    async ({ context, input }) => {
      const [result] = await context.db.insert(comment).values({
        createdBy: context.user.id,
        ...input,
      }).returning({ id: comment.id });
      return result;
    },
  ),

  byPost: protectedProcedure.comments.byPost.handler(
    async ({ context, input }) => {
      return context.db
        .select({
          id: comment.id,
          content: comment.content,
          createdAt: comment.createdAt,
          author: {
            id: user.id,
            name: user.name,
          },
        })
        .from(comment)
        .innerJoin(user, eq(comment.createdBy, user.id))
        .where(eq(comment.postId, input.postId));
    },
  ),
};

export default commentRouter;
```

### 步骤 6: 注册到主路由
```typescript
// packages/api/src/server/router/index.ts
import commentRouter from './comment';

export const appRouter = {
  posts: postRouter,
  comments: commentRouter, // 新增这行
};
```

### 步骤 7: Hono 服务器工作
Hono 服务器主要工作是:
1. 挂载 ORPC 路由到指定路径
2. 处理认证中间件
3. 应用响应包装中间件
4. 生成 OpenAPI 文档

### 步骤 8: 前端使用
```typescript
// 前端组件中
import { apiClient } from '@/integrations/tanstack-query/apiClient';

function PostComments({ postId }: { postId: string }) {
  // 获取评论 - 自动类型推导
  const { data: comments } = apiClient.comments.byPost.useQuery({ 
    postId 
  });

  // 创建评论
  const createMutation = apiClient.comments.create.useMutation();

  const handleSubmit = (content: string) => {
    createMutation.mutate({
      postId,
      content,
    });
  };

  return (
    <div>
      {comments?.map(comment => (
        <div key={comment.id}>
          <p>{comment.content}</p>
          <span>by {comment.author.name}</span>
        </div>
      ))}
    </div>
  );
}
```

## 3. 后端响应结构自定义

### 当前响应包装机制
你的 `responseWrapper` 中间件已经很好地实现了统一响应格式：

```typescript
interface ResponseWrapper {
  code: number
  msg: string  
  data: any
}
```

### 问题解决方案

#### 方案 1: 增强 ORPC 合约定义
```typescript
// 定义统一响应类型
const ApiResponse = <T>(dataSchema: T) => v.object({
  code: v.number(),
  msg: v.string(),
  data: dataSchema,
});

// 在合约中使用
const commentContract = oc
  .router({
    create: oc
      .route({...})
      .input(CreateCommentSchema)
      .output(ApiResponse(v.object({ id: v.string() }))),
  });
```

#### 方案 2: 自定义 ORPC 插件
```typescript
// packages/api/src/server/plugins/response-wrapper.ts
import { OpenAPIPlugin } from '@orpc/openapi';

export class ResponseWrapperPlugin extends OpenAPIPlugin {
  // 重写 schema 生成逻辑，自动包装响应
}
```

#### 方案 3: 修改现有 ResponseWrapper
```typescript
// apps/server/src/middlewares/response.ts
export async function responseWrapper(c: Context, next: Next) {
  await next()

  const response = c.res.clone()
  const status = response.status
  const contentType = response.headers.get('Content-Type')

  if (contentType?.includes('application/json')) {
    const body = await response.json()

    // 如果已经是包装格式，直接返回
    if (typeof body === 'object' && 'code' in body && 'msg' in body) {
      return
    }

    // 包装响应
    const wrappedResponse: ResponseWrapper = {
      code: status,
      msg: status === 200 ? 'success' : 'error',
      data: body,
    }

    // 更新响应
    c.res = c.json(wrappedResponse, status as ContentfulStatusCode)
  }
}
```

## 4. Better Auth 自定义和钱包登录

### 当前配置分析
Better Auth 目前配置了邮箱密码登录，可以进行以下自定义：

### 方案 1: 自定义认证提供商
```typescript
// packages/auth/src/server.ts
import { createAuthProvider } from 'better-auth/providers';

const walletProvider = createAuthProvider({
  id: 'wallet',
  name: 'Wallet Connect',
  
  async authenticate(request) {
    const { walletAddress, signature, message } = request;
    
    // 验证钱包签名逻辑
    const isValid = await verifyWalletSignature(walletAddress, signature, message);
    
    if (!isValid) {
      throw new Error('Invalid wallet signature');
    }

    return {
      user: {
        id: walletAddress,
        name: walletAddress,
        email: `${walletAddress}@wallet.local`,
      },
    };
  },
});

export const createAuth = (options: AuthOptions) => {
  return betterAuth({
    ...getBaseOptions(options.db),
    providers: [walletProvider],
    // 禁用邮箱密码登录
    emailAndPassword: {
      enabled: false,
    },
  });
};
```

### 方案 2: 自定义端点
```typescript
// 在 Hono 服务器中添加自定义钱包登录端点
app.post('/auth/wallet-login', async (c) => {
  const { walletAddress, signature, message } = await c.req.json();
  
  // 1. 验证钱包签名
  const isValid = await verifyWalletSignature(walletAddress, signature, message);
  if (!isValid) {
    return c.json({ error: 'Invalid signature' }, 400);
  }

  // 2. 查找或创建用户
  let user = await getUserByWalletAddress(walletAddress);
  if (!user) {
    user = await createUserFromWallet(walletAddress);
  }

  // 3. 创建会话
  const session = await auth.api.signInWithCredentials({
    email: user.email,
    password: walletAddress, // 或其他标识
  });

  return c.json({ user, session });
});
```

### 前端集成示例
```typescript
// 前端钱包登录
import { useWallet } from '@/hooks/useWallet';

export function WalletLogin() {
  const { address, signMessage } = useWallet();

  const handleWalletLogin = async () => {
    const message = `Login to app: ${Date.now()}`;
    const signature = await signMessage(message);

    const response = await fetch('/api/auth/wallet-login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        walletAddress: address,
        signature,
        message,
      }),
    });

    const result = await response.json();
    // 处理登录结果
  };

  return (
    <button onClick={handleWalletLogin}>
      Connect Wallet
    </button>
  );
}
```

## 5. 项目部署指南

### 构建打包流程

#### 当前配置分析
你的 packages 使用 tsdown 打包是合理的，这是 monorepo 的标准做法。tsdown 专门为库打包优化，可以生成多种格式（ESM、CJS）。

#### 完整部署步骤

### 步骤 1: 环境准备
```bash
# 1. 安装依赖
pnpm install

# 2. 构建所有 packages
pnpm build
```

### 步骤 2: 数据库准备
```bash
# 1. 运行数据库迁移
cd packages/db
pnpm db:migrate

# 2. 如果需要，运行 seed 数据
pnpm db:seed
```

### 步骤 3: 后端部署
```bash
# 1. 构建后端应用
cd apps/server
pnpm build

# 2. 设置环境变量
export NODE_ENV=production
export DATABASE_URL=your_production_db_url
export AUTH_SECRET=your_auth_secret
export SERVER_PORT=3001

# 3. 启动服务
pnpm start
# 或使用 PM2
pm2 start dist/index.js --name "api-server"
```

### 步骤 4: 前端部署
```bash
# 1. 构建前端应用
cd apps/web  
pnpm build

# 2. 部署到静态服务器 (Nginx/Vercel/Netlify)
# 将 dist 目录内容上传到服务器
```

### 步骤 5: Docker 部署 (推荐)
```dockerfile
# Dockerfile.server
FROM node:18-alpine

WORKDIR /app
COPY . .
RUN npm install -g pnpm
RUN pnpm install
RUN pnpm build

WORKDIR /app/apps/server
EXPOSE 3001
CMD ["pnpm", "start"]
```

```dockerfile
# Dockerfile.web  
FROM node:18-alpine as builder

WORKDIR /app
COPY . .
RUN npm install -g pnpm
RUN pnpm install
RUN pnpm build

FROM nginx:alpine
COPY --from=builder /app/apps/web/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  server:
    build:
      context: .
      dockerfile: Dockerfile.server
    environment:
      DATABASE_URL: postgresql://user:password@db:5432/myapp
      AUTH_SECRET: your-auth-secret
    ports:
      - "3001:3001"
    depends_on:
      - db

  web:
    build:
      context: .
      dockerfile: Dockerfile.web
    ports:
      - "80:80"
    depends_on:
      - server

volumes:
  postgres_data:
```

### 部署到云平台

#### Vercel 部署
```json
// vercel.json
{
  "builds": [
    {
      "src": "apps/server/src/index.ts",
      "use": "@vercel/node"
    },
    {
      "src": "apps/web/package.json", 
      "use": "@vercel/static-build",
      "config": { "distDir": "dist" }
    }
  ],
  "routes": [
    { "src": "/api/(.*)", "dest": "apps/server/src/index.ts" },
    { "src": "/(.*)", "dest": "apps/web/dist/$1" }
  ]
}
```

#### Railway/Render 部署
```yaml
# railway.toml
[build]
builder = "nixpacks"

[deploy]
startCommand = "pnpm start"
healthcheckPath = "/health"
healthcheckTimeout = 300
restartPolicyType = "always"
```

### 生产环境检查清单
- [ ] 环境变量配置完整
- [ ] 数据库连接和迁移
- [ ] HTTPS 证书配置
- [ ] 域名和 CORS 设置
- [ ] 监控和日志系统
- [ ] 备份策略
- [ ] 性能优化 (CDN、缓存)
- [ ] 安全配置 (防火墙、限流)

## 总结

这个项目采用了非常现代化的全栈架构：
1. **类型安全**: 从数据库到前端的完整类型链路
2. **模块化**: 通过 monorepo 实现代码复用和维护性
3. **标准化**: 统一的响应格式和错误处理
4. **可扩展**: 支持自定义认证和业务逻辑

通过这套架构，你可以快速开发类型安全的全栈应用，同时保持良好的代码组织和可维护性。
